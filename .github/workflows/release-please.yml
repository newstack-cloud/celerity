name: Release Please

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs: {}

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  release-please:
    runs-on: ubuntu-latest
    outputs:
      releases_created: ${{ steps.release.outputs.releases_created }}
      paths_released: ${{ steps.release.outputs.paths_released }}
    steps:
      - uses: googleapis/release-please-action@v4
        id: release
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json

  post-process-tags:
    needs: release-please
    if: ${{ needs.release-please.outputs.releases_created == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      - name: Process release tags
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Map component names to paths for Go module proxy indexing.
          # Go modules in a monorepo need path-based tags (e.g. apps/cli/v1.0.0)
          # for the Go module proxy, but release-please creates component-based
          # tags (e.g. cli/v1.0.0). This step creates the path-based tag and
          # re-associates the GitHub release.
          declare -A GO_COMPONENTS=(
            ["cli"]="apps/cli"
          )

          # Map component names to release workflow files.
          # Tags created by GitHub Actions (via GITHUB_TOKEN) do not trigger
          # on.push.tags workflows, so we dispatch release workflows explicitly.
          declare -A RELEASE_WORKFLOWS=(
            ["runtime-sdk-node"]="lib-node-runtime-sdk-release.yml"
            ["runtime-sdk-python"]="lib-python-runtime-sdk-release.yml"
            ["runtime-sdk-ffi"]="lib-java-csharp-sdk-release.yml"
            ["runtime-nodejs"]="runtime-nodejs-release.yml"
            ["runtime-python"]="runtime-python-release.yml"
          )

          for tag in $(git tag --points-at HEAD); do
            if [[ "$tag" =~ ^([^/]+)/(.+)$ ]]; then
              component="${BASH_REMATCH[1]}"
              version="${BASH_REMATCH[2]}"

              echo "Processing release: component=$component version=$version tag=$tag"

              # Handle Go module tags
              if [[ -n "${GO_COMPONENTS[$component]}" ]]; then
                path="${GO_COMPONENTS[$component]}"
                new_tag="${path}/${version}"

                if [[ "$tag" != "$new_tag" ]]; then
                  echo "Creating Go module tag: $new_tag (from $tag)"
                  git tag "$new_tag" HEAD
                  git push origin "$new_tag"

                  echo "Associating $new_tag with release $tag"
                  gh release edit "$tag" --tag "$new_tag"

                  MODULE="github.com/${{ github.repository }}/${path}"
                  echo "Indexing Go module: ${MODULE}@${version}"
                  GOPROXY=proxy.golang.org go list -m "${MODULE}@${version}" || echo "Warning: Failed to index ${MODULE}@${version}"
                fi
              fi

              # Trigger component-specific release workflows
              if [[ -n "${RELEASE_WORKFLOWS[$component]}" ]]; then
                workflow_file="${RELEASE_WORKFLOWS[$component]}"
                if gh workflow view "$workflow_file" &>/dev/null; then
                  echo "Triggering $workflow_file for tag: $tag"
                  gh workflow run "$workflow_file" -f tag="$tag"
                fi
              fi
            fi
          done

  # Cascade core library releases to SDK packages.
  # When shared Rust crates (runtime-core, runtime-consumers, runtime-ws) are
  # released, SDK packages that compile them need new releases too.
  # This job touches a .core-version file in each SDK directory so release-please
  # sees a file change and opens an SDK release PR on the next run.
  #
  # Workaround for release-please lacking an `additional-paths` feature
  # (see https://github.com/googleapis/release-please/pull/2534).
  cascade-core-to-sdks:
    needs: [release-please, post-process-tags]
    if: ${{ needs.release-please.outputs.releases_created == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: main

      - name: Cascade core releases to SDK directories
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          CORE_COMPONENTS="runtime-core runtime-consumers runtime-ws"

          # Map SDK directories to their release-please component names
          declare -A SDK_COMPONENTS=(
            ["libs/runtime/sdk/node"]="runtime-sdk-node"
            ["libs/runtime/sdk/python"]="runtime-sdk-python"
            ["libs/runtime/sdk"]="runtime-sdk-ffi"
          )

          # Collect core component tags created in this release
          core_tags=()
          for tag in $(git tag --points-at HEAD); do
            for comp in $CORE_COMPONENTS; do
              if [[ "$tag" == "$comp/"* ]]; then
                core_tags+=("$tag")
                echo "Core release detected: $tag"
              fi
            done
          done

          if [[ ${#core_tags[@]} -eq 0 ]]; then
            echo "No core component releases found, skipping SDK cascade."
            exit 0
          fi

          # Collect release notes from each core release
          release_notes=""
          for tag in "${core_tags[@]}"; do
            body=$(gh release view "$tag" --json body -q '.body' 2>/dev/null || echo "")
            if [[ -n "$body" ]]; then
              release_notes+="$body"$'\n\n'
            fi
          done

          # Create a separate commit per SDK so release-please associates
          # each change with the correct SDK component and changelog.
          for sdk_dir in "${!SDK_COMPONENTS[@]}"; do
            sdk_component="${SDK_COMPONENTS[$sdk_dir]}"
            if [[ -d "$sdk_dir" ]]; then
              printf "%s\n" "${core_tags[@]}" > "$sdk_dir/.core-version"
              git add "$sdk_dir/.core-version"
              commit_msg="deps(${sdk_component}): update core dependencies"
              commit_msg+=$'\n\n'"Core releases: ${core_tags[*]}"
              if [[ -n "$release_notes" ]]; then
                commit_msg+=$'\n\n'"$release_notes"
              fi
              git commit -m "$commit_msg"
              echo "Created cascade commit for $sdk_component"
            fi
          done

          git push origin main

          # Commits made with GITHUB_TOKEN don't trigger on.push workflows,
          # so explicitly dispatch the release-please workflow to pick up
          # the .core-version file changes in SDK directories.
          gh workflow run release-please.yml
